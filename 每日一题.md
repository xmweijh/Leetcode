#### [1590. 使数组和能被 P 整除 - 力扣（Leetcode）](https://leetcode.cn/problems/make-sum-divisible-by-p/description/)



#### [2383. 赢得比赛需要的最少训练时长 - 力扣（Leetcode）](https://leetcode.cn/problems/minimum-hours-of-training-to-win-a-competition/)

返回击败全部 `n` 个对手需要训练的 **最少** 小时数目。

题目很长，看着吓人  但这个对手顺序是固定的，就简单了很多

首先 精力是一定会减少的  所以我们必须训练到  大于对手精力和

然后判断经验值

initialExperience记录当前经验，与对手相比，不大于 则训练，让它大于。

```js
var minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {
    let trainEnergy = energy.reduce((a,b) => a+b) - initialEnergy + 1;
    trainEnergy = trainEnergy > 0 ? trainEnergy : 0 
    let trainExperience = 0
    for(let i = 0; i < experience.length; i++) {
        if(initialExperience <= experience[i]) {
            trainExperience += experience[i] - initialExperience + 1
            initialExperience += experience[i] - initialExperience + 1
        }
        initialExperience += experience[i]
    }
    return trainExperience+ trainEnergy
};
```

#### [1605. 给定行和列的和求可行矩阵 - 力扣（Leetcode）](https://leetcode.cn/problems/find-valid-matrix-given-row-and-column-sums/)

暴力枚举  过于暴力

没想到其它方法  感觉应该是数学推导

这道题可以使用贪心算法来解决。我们可以从左上角开始构建矩阵，依次填充每个格子。每次我们需要填充的格子是当前行和当前列中剩余未填充的格子中，值最小的格子。

具体来说，假设当前需要填充的格子是第 i 行、第 j 列的格子，那么我们可以将它的值设为 min(rowSum[i], colSum[j])。填充完这个格子后，我们将 rowSum[i] 和 colSum[j] 减去相应的值，表示第 i 行和第 j 列已经被填充了。

当我们填充完最后一个格子时，就构建出了一个符合要求的矩阵。具体实现过程可以参考下面的代码：

```js
function restoreMatrix(rowSum, colSum) {
  const n = rowSum.length;
  const m = colSum.length;
  const matrix = new Array(n).fill().map(() => new Array(m).fill(0));
  for (let i = 0, j = 0; i < n && j < m;) {
    const val = Math.min(rowSum[i], colSum[j]);
    matrix[i][j] = val;
    rowSum[i] -= val;
    colSum[j] -= val;
    if (rowSum[i] === 0) i++;
    if (colSum[j] === 0) j++;
  }
  return matrix;
}
```

时间复杂度为 O(nm)，其中 n 和 m 分别是 rowSum 和 colSum 的长度。

不要想得太复杂，因为有很多种解法。贪心即可。

竟可能的消耗行和，列和。

且被消耗完就可以换行或列，因为其它肯定为0。

#### [1615. 最大网络秩 - 力扣（Leetcode）](https://leetcode.cn/problems/maximal-network-rank/)

求两个节点的最大秩

~~统计每个节点出现的次数，然后前两名相加就可得到~~

这样会重复计算边  需要去重

```js
var maximalNetworkRank = function (n, roads) {
    // 初始化城市网络秩数组
    const cityRank = new Array(n).fill(0);

    // 遍历所有的道路，记录城市的网络秩
    for (const [a, b] of roads) {
        cityRank[a]++;
        cityRank[b]++;
    }

    // 计算最大网络秩
    let maxRank = 0;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            let rank = cityRank[i] + cityRank[j];
            // 两城市之间的直线只记录一次
            if (roads.some(([a, b]) => a === i && b === j || a === j && b === i)) {
                rank--;
            }
            maxRank = Math.max(maxRank, rank);
        }
    }

    return maxRank;
};
```

在这个实现中，我们首先创建了一个长度为 `n` 的数组 `cityRank`，用于记录每个城市的网络秩。然后遍历所有的道路，更新相应的城市网络秩。

接下来，我们使用两个嵌套的循环来遍历所有的不同城市对。对于每对城市，我们计算它们的网络秩，同时检查它们之间是否有直接的道路。如果有，我们需要减去其中一个道路的贡献，以避免重复计算。最后，我们返回所有城市对的最大网络秩。

这个实现的时间复杂度为 $O(n^2)$，其中 $n$ 是城市的数量。

上述代码可以在遍历道路的时候直接记录两点之间是否相连，减少some操作

```js
var maximalNetworkRank = function (n, roads) {
    // 初始化城市网络秩数组
    const cityRank = new Array(n).fill(0);
    // 初始化记录两城市是否直接相连
    const connerct = new Array(n).fill().map(()=> new Array(n).fill(0))

    // 遍历所有的道路，记录城市的网络秩
    for (const [a, b] of roads) {
        connerct[a][b] = true
        connerct[b][a] = true
        cityRank[a]++
        cityRank[b]++
    }

    // 计算最大网络秩
    let maxRank = 0;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            let rank = cityRank[i] + cityRank[j];
            // 两城市之间的直线只记录一次
            if (connerct[i][j]) {
                rank--;
            }
            maxRank = Math.max(maxRank, rank);
        }
    }

    return maxRank;
};
```

#### [2488. 统计中位数为 K 的子数组 - 力扣（Leetcode）](https://leetcode.cn/problems/count-subarrays-with-median-k/)

中位数为k  所以首先一定会包含k

然后根据k来扩张其它结果

偶数扩张 需要满足新增元素大于k，这样才能保持偶数数组中位数位于左边

奇数扩张 需要满足小于

回溯？  会重复回溯  导致无法结束

不会

前缀和：

```js
var countSubarrays = function(nums, k) {
    const n = nums.length;
    let kIndex = nums.indexOf(k);

    let ans = 0;
    const counts = new Map();
    counts.set(0, 1);
    let sum = 0;
    for (let i = 0; i < n; i++) {
        sum += sign(nums[i] - k);
        if (i < kIndex) {
            counts.set(sum, (counts.get(sum) || 0) + 1);
        } else {
            // 要满足[i,j]子数组中位数为k  则前j个数组中大于k的 - 前i个数组中大于k的应该为0或者1
            const prev0 = (counts.get(sum) || 0);  // sum[i] = sum[j]
            const prev1 = (counts.get(sum - 1) || 0);   // sum[i] = sum[j]+1
            ans += prev0 + prev1;
        }
    }
    return ans;
}

const sign = (num) => {
    if (num === 0) {
        return 0;
    }
    return num > 0 ? 1 : -1;
};
```

#### [2389. 和有限的最长子序列 - 力扣（Leetcode）](https://leetcode.cn/problems/longest-subsequence-with-limited-sum/)

第一印象：前缀和

索然子序列意思是不改变元素顺序，因为不需要连续，改变了对本题没有影响。然后是最大长度，所以使用排序后的前缀和，然后在里面查找q值，就能得到最大长度。

```js
var answerQueries = function(nums, queries) {
    nums.sort((a,b)=> a-b)
    const n = nums.length;
    const m = queries.length;
    const presum = new Array(n).fill(0);
    const ans = new Array(m).fill(0);
    presum[0] = nums[0]
    for (let i = 1; i < n; i++) {
      presum[i] = presum[i - 1] + nums[i];
    }
    
    for (let i = 0; i < m; i++) {
      const q = queries[i];
      if(q<presum[0]) {
        ans.push[0]
        continue
      }
      let left = 0;
      let right = n;
      
      while (left < right) {
        const mid = Math.floor((left + right + 1) / 2);
        if (presum[mid] <= q) {
          left = mid;
        } else {
          right = mid - 1;
        }
      }
      
      ans[i] = left+1;
    }
    
    return ans;
};
```

#### [1616. 分割两个字符串得到回文串 - 力扣（Leetcode）](https://leetcode.cn/problems/split-two-strings-to-make-palindrome/)

```js
var checkPalindromeFormation = function(a, b) {
    return checkConcatenation(a, b) || checkConcatenation(b, a);
}

const checkConcatenation = (a, b) => {
    const n = a.length;
    let left = 0, right = n - 1;
    while (left < right && a[left] === b[right]) {
        left++;
        right--;
    }
    if (left >= right) {
        return true;
    }
    return checkSelfPalindrome(a, left, right) || checkSelfPalindrome(b, left, right);
}

const checkSelfPalindrome = (a, left, right) => {
    while (left < right && a[left] === a[right]) {
        left++;
        right--;
    }
    return left >= right;
};
```

#### [1012. 至少有 1 位重复的数字 - 力扣（Leetcode）](https://leetcode.cn/problems/numbers-with-repeated-digits/)

最简单暴力 😄

该函数使用了一个循环，遍历了从 1 到 n 的所有正整数，并对于每个正整数检查是否有重复数字。在内部，它使用了一个集合来存储当前数字的各个位数，如果发现重复的数字，就将计数器加一，并跳出内部循环。最后，该函数返回计数器的值，即在 [1, n] 范围内至少有一位重复数字的正整数的个数。

```js
var numDupDigitsAtMostN = function(n) {
    let count = 0;
    for (let i = 1; i <= n; i++) {
      let digits = new Set();
      let num = i;
      while (num > 0) {
        let digit = num % 10;
        if (digits.has(digit)) {
          count++;
          break;
        }
        digits.add(digit);
        num = Math.floor(num / 10);
      }
    }
    return count;
};
```

果然超时了

#### [1625. 执行操作后字典序最小的字符串 - 力扣（Leetcode）](https://leetcode.cn/problems/lexicographically-smallest-string-after-applying-operations/description/)

BFS遍历每次累加或者轮换，直到所有可能情况都遍历过

```js
var findLexSmallestString = function (s, a, b) {
    let ans = s, queue = [s], visited = new Set().add(s);

    while (queue.length) {
        const next = [];

        for (const q of queue) {
            // 是否最小
            if (q < ans) ans = q;

            // 轮转
            const rs = q.slice(q.length - b) + q.slice(0, q.length - b);
            if (!visited.has(rs)) visited.add(rs), next.push(rs);

            // 累加
            const arr = [...q];
            for (let i = 1; i < q.length; i += 2) {
                arr[i] = `${(+q[i] + a) % 10}`;
            }
            const as = arr.join('');
            if (!visited.has(as)) visited.add(as), next.push(as);
        }

        queue = next;
    }

    return ans;
}
```

#### [2469. 温度转换 - 力扣（Leetcode）](https://leetcode.cn/problems/convert-the-temperature/)

```js
var convertTemperature = function(celsius) {
    return [celsius+273.15, celsius*1.8+32]
};
```

#### [1626. 无矛盾的最佳球队 - 力扣（Leetcode）](https://leetcode.cn/problems/best-team-with-no-conflicts/)

年龄小的分数大于年龄大的会有矛盾，要无矛盾且得分最高。

先将运动员按年龄排序？年龄相同的按照分数升序排序，然后遍历。

用动态规划记录以第 i 名球员为最后一名球员的最大得分。

```js
var bestTeamScore = function (scores, ages) {
    const n = scores.length;
    const players = new Array(n);
    for (let i = 0; i < n; i++) {
        players[i] = { score: scores[i], age: ages[i] };
    }
    // 按照年龄升序排序，年龄相同的按照分数升序排序
    players.sort((a, b) => {
        if (a.age !== b.age) {
            return a.age - b.age;
        }
        return a.score - b.score;
    });
    // dp[i] 表示以第 i 名球员为最后一名球员的最大得分
    const dp = new Array(n).fill(0);
    let maxScore = 0;
    for (let i = 0; i < n; i++) {
        dp[i] = players[i].score;
        for (let j = 0; j < i; j++) {
            // 满足无矛盾条件
            if (players[i].score >= players[j].score || players[i].age === players[j].age) {
                dp[i] = Math.max(dp[i], dp[j] + players[i].score);
            }
        }
        maxScore = Math.max(maxScore, dp[i]);
    }
    return maxScore;
};
```

#### [1630. 等差子数组 - 力扣（Leetcode）](https://leetcode.cn/problems/arithmetic-subarrays/)

最简答的方法  遍历每个查询范围 然后排序 遍历 看是否是等差数列

```js
var checkArithmeticSubarrays = function(nums, l, r) {
    const len  = nums.length
    const lLen = l.length
    const ans = []
    for(let i = 0; i < lLen; i++) {
        ans.push(nums.slice(l[i],r[i]+1).sort((a,b) =>a-b))
    }
    return ans.map((value)=>isArithmetic(value))
};

var isArithmetic = (nums) => {
    if(nums.length<2) return false
    let ari = nums[1]-nums[0]
    for(let i = 2; i < nums.length; i++) {
        if(nums[i]-nums[i-1] !== ari) return false
    }
    return true
}
```

#### [1574. 删除最短的子数组使剩余数组有序 - 力扣（Leetcode）](https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/)

```js
var findLengthOfShortestSubarray = function(arr) {
    let n = arr.length, j = n - 1;
    while (j > 0 && arr[j - 1] <= arr[j]) {
        j--;
    }
    if (j === 0) {
        return 0;
    }
    let res = j;
    for (let i = 0; i < n; i++) {
        while (j < n && arr[j] < arr[i]) {
            j++;
        }
        res = Math.min(res, j - i - 1);
        if (i + 1 < n && arr[i] > arr[i + 1]) {
            break;
        }
    }
    return res;
};
```

双指针先找到尾部不符合规则的第一个元素j  把前j个去掉一定和规则 所以结果暂时设为j

然后从左边遍历  看从中间删除需要删除多少个 同时前i个也要满足非递减

#### [2395. 和相等的子数组 - 力扣（Leetcode）](https://leetcode.cn/problems/find-subarrays-with-equal-sum/)

滑动窗口 并用set记录值

```js
var findSubarrays = function(nums) {
    let sum = new Set()
    for(let i = 1; i < nums.length; i++) {
        let tmp = nums[i] + nums[i-1]
        if(sum.has(tmp)) return true
        sum.add(tmp)
    }
    return false
};
```

#### [1638. 统计只差一个字符的子串数目 - 力扣（Leetcode）](https://leetcode.cn/problems/count-substrings-that-differ-by-one-character/)

枚举所有可能

```js
var countSubstrings = function(s, t) {
    let res = 0;

    // len 记录当前子串长度
    for (let len = 1; len <= s.length; len++) {
      for (let i = 0; i + len - 1 < s.length; i++) {
        let sStr = s.substring(i, i + len);
  
        for (let j = 0; j + len - 1 < t.length; j++) {
          let tStr = t.substring(j, j + len);
          let diffCount = 0;
  
          for (let k = 0; k < len; k++) {
            if (sStr[k] !== tStr[k]) {
              diffCount++;
            }
          }
  
          if (diffCount === 1) {
            res++;
          }
        }
      }
    }
  
    return res;
};
```

#### [1092. 最短公共超序列 - 力扣（Leetcode）](https://leetcode.cn/problems/shortest-common-supersequence/)

```js
var shortestCommonSupersequence = function (str1, str2) {
    let m = str1.length, n = str2.length;
    // dp记录最长公共子序列长度
    const dp = new Array(m + 1).fill().map(() => new Array(n + 1).fill(0))

    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            // 若相等则+1
            if (str1[i - 1] === str2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    let i = m, j = n;
    const result = [];
    while (i > 0 && j > 0) {
        if (str1[i - 1] === str2[j - 1]) {
            result.unshift(str1[i - 1]);
            i--;
            j--;
        } else if (dp[i - 1][j] > dp[i][j - 1]) {
            // 说明在正向迭代dp的时候，str1[i-1]并未作出贡献，也就是说 str1[i-1] 属于 str1 特有的字符 直接插入
            result.unshift(str1[i - 1]);
            i--;
        } else {
            result.unshift(str2[j - 1]);
            j--;
        }
    }
    while (i > 0) {
        result.unshift(str1[i - 1]);
        i--;
    }
    while (j > 0) {
        result.unshift(str2[j - 1]);
        j--;
    }
    return result.join('');
};
```

#### [1039. 多边形三角剖分的最低得分 - 力扣（Leetcode）](https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/)

毫无思路,GG

动态规划：

- 由于每个三角形的值是其三个顶点的值的乘积，因此我们需要计算每个三角形的值，并将其存储在一个二维数组 dp 中。 dp[i][j] 表示从第 i 个顶点到第 j 个顶点之间的多边形的最低得分。
- 我们使用动态规划来计算 dp 数组。 首先，对于每个长度为 3 的子多边形，其得分就是它的三个顶点之间的乘积。 然后，对于每个长度大于 3 的子多边形，我们可以将其分成两个子多边形，然后计算它们的得分，并将它们的得分相加再加上三个划分点构成三角形的大小，以得到这个多边形的得分。

```js
var minScoreTriangulation = function (values) {
    const n = values.length;
    const dp = new Array(n).fill(null).map(() => new Array(n).fill(0));

    for (let len = 3; len <= n; len++) {
        for (let i = 0; i <= n - len; i++) {
            const j = i + len - 1;
            dp[i][j] = Number.MAX_SAFE_INTEGER;
            for (let k = i + 1; k < j; k++) {
                dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j] + values[i] * values[k] * values[j]);
            }
        }
    }

    return dp[0][n - 1];
};
```

递归与记忆化搜索：

- 我们使用递归和记忆化搜索来计算多边形的最低得分。 dfs(i, j) 函数返回从第 i 个顶点到第 j 个顶点之间的多边形的最低得分。
- 首先，如果 j - i < 2，则多边形不存在，其得分为 0。
- 然后，我们使用 memo 数组来存储计算过的值。如果 memo[i][j] 不为空，则我们已经计算过从第 i 个顶点到第 j 个顶点之间的多边形的最低得分，并可以直接返回 memo[i][j]。
- 否则，我们使用一个循环遍历所有可能的三角形，并计算它们的得分。 对于每个三角形，我们计算分数，并使用 Math.min() 函数来找到分数最低的三角形。
- 最后，我们将计算得到的最低得分存储在 memo[i][j] 中，并返回该值。

```js
var minScoreTriangulation = function(values) {
    const n = values.length;
    const memo = new Array(n).fill(null).map(() => new Array(n).fill(null));
    
    const dfs = (i, j) => {
        if (j - i < 2) {
            return 0;
        }
        if (memo[i][j] !== null) {
            return memo[i][j];
        }
        let ans = Number.MAX_SAFE_INTEGER;
        for (let k = i + 1; k < j; k++) {
            ans = Math.min(ans, dfs(i, k) + dfs(k, j) + values[i] * values[k] * values[j]);
        }
        memo[i][j] = ans;
        return ans;
    };
    
    return dfs(0, n-1);
};
```

第二种更好理解

